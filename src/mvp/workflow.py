import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import dotenv
from pathlib import Path
from typing_extensions import TypedDict
from typing import Dict, Optional

from langgraph.graph import StateGraph, START, END

from extraction import PDFTextExtractor
from llms import get_llm
from nodes import *

dotenv.load_dotenv()


llm = get_llm(platform="google", model="default")

class State(TypedDict):
    """
    Workflow state.
    
    Attributes:
        input: User input prompt
        pdf_path: Path to the PDF file
        output_dir: Directory to store output files
        extracted_text: Text extracted from the PDF
        codebase_structure: Structure of the codebase
        plan_response: Code plan generated by the planner
        code_response: Generated code files
        master_response: Feedback from the master review
        fix_attempts: Number of attempts to fix code
        max_fix_attempts: Maximum number of fix attempts allowed
    """
        

    input: str
    pdf_path: str
    output_dir: str

    extracted_text: str
    codebase_structure: Optional[CodebaseStructure]
    plan_response: Optional[Dict[str, FilePlan]]
    code_response: Optional[Dict[str, GeneratedFile]]
    master_response: Optional[CodebaseFeedback]

    fix_attempts: int
    max_fix_attempts: int
    


def extract_text_node(state: State) -> State:    
    """
    Extract text from the PDF file specified in the state.
    """
    state["extracted_text"] = PDFTextExtractor(state["pdf_path"], state["output_dir"]).extract()
    return state

def codebase_structure_node(state: State) -> State:
    """
    Generate codebase structure from extracted text.
    """
    state["codebase_structure"] = generate_codebase_structure(state["extracted_text"], state["input"], llm)
    return state

def code_planner_node(state: State) -> State:
    """
    Generate code plan from extracted text.
    """
    state["plan_response"] = generate_file_plans(state["codebase_structure"], llm)
    return state


def coder_node(state: State) -> State:
    """
    Generate code based on the plan.
    """
    state["code_response"] = generate_code(state["plan_response"], llm)
    return state


def master_review_node(state: State) -> State:
    """
    Review generated code against the plan.
    """
    state["master_response"] = review_codebase(state["code_response"], state["plan_response"], llm)
    return state


def code_fixer_node(state: State) -> State:
    """
    Fix code issues identified in review.
    """
    state["code_response"] = fix_code_issues(state["master_response"], state["code_response"], llm)
    state["fix_attempts"] += 1
    return state

def should_continue(state: State) -> bool:
    """
    Determine if workflow should continue fixing code.
    
    Args:
        state: Current workflow state
        
    Returns:
        bool: True if should continue, False otherwise
    """
    max_attempts = state.get("max_fix_attempts", 3)
    current_attempts = state.get("fix_attempts", 0)
    
    return (not state["master_response"].satisfied) and (current_attempts < max_attempts)


def create_workflow() -> StateGraph:
    """
    Create the workflow graph.
    
    Args:
        max_fix_attempts: Maximum number of fix attempts allowed
        
    Returns:
        StateGraph: Compiled workflow graph
    """
    workflow = StateGraph(State)
    
    # Add nodes
    workflow.add_node("extract_text", extract_text_node)
    workflow.add_node("codebase_structure", codebase_structure_node)
    workflow.add_node("code_planner", code_planner_node)
    workflow.add_node("coder", coder_node)
    workflow.add_node("master_review", master_review_node)
    workflow.add_node("code_fixer", code_fixer_node)
    
    # Set edges
    workflow.set_entry_point("extract_text")
    workflow.add_edge("extract_text", "codebase_structure")
    workflow.add_edge("codebase_structure", "code_planner")
    workflow.add_edge("code_planner", "coder")
    workflow.add_edge("coder", "master_review")
    
    # Conditional edge
    workflow.add_conditional_edges(
        "master_review",
        should_continue,
        {
            True: "code_fixer",
            False: END
        }
    )
    
    workflow.add_edge("code_fixer", "master_review")
    
    # Compile
    return workflow.compile()

if __name__ == "__main__":
    import sys
    
    workflow = create_workflow()

    initial_state =     {
        "input": "Implement a system for image classification using a CNN.",
        "pdf_path": sys.argv[1],
        "output_dir": sys.argv[2],
        "fix_attempts": 0,
        "max_fix_attempts": 3,
    }
    
    result = workflow.invoke(initial_state)
    print(result)
